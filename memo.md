# 3章データ型
## No.17 8進数リテラルで混乱を招く

```golang
sum := 100 + 010
fmt.Println(sum) // 108
```

Goでは、0から始まる整数リテラルは8進数とみなされる。

## 8進数の使いどころ
ファイルの権限など。
0644はLinuxの特定の権限を表している。
```golang
os.OpenFile("memo.md", os.O_CREATE, 0644)
```

## No.18 整数のオーバーフローを無視する
カウンターなどの計算で

```go
var counter int32 = math.MaxInt32
counter++
fmt.Println(counter) //-2147483648
```

## No.19 浮動小数点を理解していない
floatは整数の小数点を表現できない問題を解決するための方法。
開発者が意識するのは、==演算子を使ってfloatを計算する場合は、不正確な結果になる場合がある。

## No.20 スライスの長さと容量を理解していない。

## No.21 非効率なスライスの初期化

makeを使ってスライスを初期化する際に、長さと容量を指定します。
Golangは基底配列がいっぱいになると容量を増やすが、この処理は、GCが一時的に基底配列を解放するために追加処理が発生する。
効率的な実装では基底配列をし利用しているため、割り当て回数を減らしている。

## No.22 nilスライスと空スライスに混乱する

- 長さが0なら、スライスは空です。
- nilと等しいなら、スライスはnilです。

nilスライスと空スライスの主な違いは、割り当てを関するもので、nilスライスの初期化は割り当てが必要はないが、空スライスの場合は必要。
nilスライスであっても、appendを呼び出すと動作する。

## No.23 スライスが空か否かを適切に検査しない。

nilであるかを確認するのではなく、長さを調べるようにする。
空スライスとnilスライスを意識したくないため。

## No.24 スライスのコピーを正しく行わない
